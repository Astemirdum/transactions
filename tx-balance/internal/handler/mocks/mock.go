// Code generated by MockGen. DO NOT EDIT.
// Source: service.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
	context "context"
	reflect "reflect"

	broker "github.com/Astemirdum/transactions/tx-balance/internal/handler/broker"
	v1 "github.com/Astemirdum/transactions/tx-balance/models/v1"
	gomock "github.com/golang/mock/gomock"
)

// MockBalance is a mock of Balance interface.
type MockBalance struct {
	ctrl     *gomock.Controller
	recorder *MockBalanceMockRecorder
}

// MockBalanceMockRecorder is the mock recorder for MockBalance.
type MockBalanceMockRecorder struct {
	mock *MockBalance
}

// NewMockBalance creates a new mock instance.
func NewMockBalance(ctrl *gomock.Controller) *MockBalance {
	mock := &MockBalance{ctrl: ctrl}
	mock.recorder = &MockBalanceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBalance) EXPECT() *MockBalanceMockRecorder {
	return m.recorder
}

// CashOut mocks base method.
func (m *MockBalance) CashOut(ctx context.Context, msg *v1.CashOut) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CashOut", ctx, msg)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CashOut indicates an expected call of CashOut.
func (mr *MockBalanceMockRecorder) CashOut(ctx, msg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CashOut", reflect.TypeOf((*MockBalance)(nil).CashOut), ctx, msg)
}

// CreateBalance mocks base method.
func (m *MockBalance) CreateBalance(ctx context.Context, userID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBalance", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBalance indicates an expected call of CreateBalance.
func (mr *MockBalanceMockRecorder) CreateBalance(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBalance", reflect.TypeOf((*MockBalance)(nil).CreateBalance), ctx, userID)
}

// GetBalance mocks base method.
func (m *MockBalance) GetBalance(ctx context.Context, userID int) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", ctx, userID)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockBalanceMockRecorder) GetBalance(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockBalance)(nil).GetBalance), ctx, userID)
}

// ListCashedUserIDs mocks base method.
func (m *MockBalance) ListCashedUserIDs(ctx context.Context) ([]int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCashedUserIDs", ctx)
	ret0, _ := ret[0].([]int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCashedUserIDs indicates an expected call of ListCashedUserIDs.
func (mr *MockBalanceMockRecorder) ListCashedUserIDs(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCashedUserIDs", reflect.TypeOf((*MockBalance)(nil).ListCashedUserIDs), ctx)
}

// MockAuth is a mock of Auth interface.
type MockAuth struct {
	ctrl     *gomock.Controller
	recorder *MockAuthMockRecorder
}

// MockAuthMockRecorder is the mock recorder for MockAuth.
type MockAuthMockRecorder struct {
	mock *MockAuth
}

// NewMockAuth creates a new mock instance.
func NewMockAuth(ctrl *gomock.Controller) *MockAuth {
	mock := &MockAuth{ctrl: ctrl}
	mock.recorder = &MockAuthMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuth) EXPECT() *MockAuthMockRecorder {
	return m.recorder
}

// Auth mocks base method.
func (m *MockAuth) Auth(ctx context.Context, session string) (int32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Auth", ctx, session)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Auth indicates an expected call of Auth.
func (mr *MockAuthMockRecorder) Auth(ctx, session interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Auth", reflect.TypeOf((*MockAuth)(nil).Auth), ctx, session)
}

// MockCashOutBroker is a mock of CashOutBroker interface.
type MockCashOutBroker struct {
	ctrl     *gomock.Controller
	recorder *MockCashOutBrokerMockRecorder
}

// MockCashOutBrokerMockRecorder is the mock recorder for MockCashOutBroker.
type MockCashOutBrokerMockRecorder struct {
	mock *MockCashOutBroker
}

// NewMockCashOutBroker creates a new mock instance.
func NewMockCashOutBroker(ctrl *gomock.Controller) *MockCashOutBroker {
	mock := &MockCashOutBroker{ctrl: ctrl}
	mock.recorder = &MockCashOutBrokerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCashOutBroker) EXPECT() *MockCashOutBrokerMockRecorder {
	return m.recorder
}

// PublishCashOut mocks base method.
func (m *MockCashOutBroker) PublishCashOut(subjectName string, cashMsg *v1.CashOutMsg) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishCashOut", subjectName, cashMsg)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishCashOut indicates an expected call of PublishCashOut.
func (mr *MockCashOutBrokerMockRecorder) PublishCashOut(subjectName, cashMsg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishCashOut", reflect.TypeOf((*MockCashOutBroker)(nil).PublishCashOut), subjectName, cashMsg)
}

// SetCashOutHandler mocks base method.
func (m *MockCashOutBroker) SetCashOutHandler(cashOut broker.CashOut) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCashOutHandler", cashOut)
}

// SetCashOutHandler indicates an expected call of SetCashOutHandler.
func (mr *MockCashOutBrokerMockRecorder) SetCashOutHandler(cashOut interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCashOutHandler", reflect.TypeOf((*MockCashOutBroker)(nil).SetCashOutHandler), cashOut)
}

// StartCashOutByUser mocks base method.
func (m *MockCashOutBroker) StartCashOutByUser(ctx context.Context, userID int, unSubCh chan int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartCashOutByUser", ctx, userID, unSubCh)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartCashOutByUser indicates an expected call of StartCashOutByUser.
func (mr *MockCashOutBrokerMockRecorder) StartCashOutByUser(ctx, userID, unSubCh interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartCashOutByUser", reflect.TypeOf((*MockCashOutBroker)(nil).StartCashOutByUser), ctx, userID, unSubCh)
}

// UnsubscribeUser mocks base method.
func (m *MockCashOutBroker) UnsubscribeUser(userID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnsubscribeUser", userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnsubscribeUser indicates an expected call of UnsubscribeUser.
func (mr *MockCashOutBrokerMockRecorder) UnsubscribeUser(userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeUser", reflect.TypeOf((*MockCashOutBroker)(nil).UnsubscribeUser), userID)
}
